// quiz.fix.ts - Minimal fix for "abi is not iterable" issue in MiniPay
import { createPublicClient, createWalletClient, custom, http, getContract, Hex } from 'viem'
import { celo } from './chains'
import abiImport from '../abi/SinglePlayerQuiz.json'

// Safely process ABI to ensure it's always iterable
const abi = Array.isArray(abiImport.abi) ? abiImport.abi : 
            Array.isArray(abiImport) ? abiImport : [];

export const QUIZ_ADDRESS = (import.meta.env.VITE_QUIZ_ADDRESS as `0x${string}`) || '0x0000000000000000000000000000000000000000'
export const pub = createPublicClient({ chain: celo, transport: http(import.meta.env.VITE_CELO_RPC || 'https://forno.celo.org') })

// ERC20 ABI explicitly defined to avoid any issues
const erc20Abi = [
  { type: 'function', name: 'allowance', stateMutability: 'view', inputs: [{name:'owner',type:'address'},{name:'spender',type:'address'}], outputs: [{type:'uint256'}] },
  { type: 'function', name: 'approve', stateMutability: 'nonpayable', inputs: [{name:'spender',type:'address'},{name:'amount',type:'uint256'}], outputs: [{type:'bool'}] },
] as const;

export function quizContract() {
  try {
    // Ensure ABI is valid before creating contract
    if (abi.length === 0) {
      console.error("Warning: ABI appears to be empty or invalid");
    }
    return getContract({ address: QUIZ_ADDRESS, abi, client: pub })
  } catch (error) {
    console.error("Error creating quiz contract:", error);
    // Return a minimal mock with the required functions if contract creation fails
    return {
      read: {
        entryFee: async () => BigInt(10000),
        cUSD: async () => "0x765DE816845861e75A25fCA122bb6898B8B1282a"
      }
    };
  }
}

// The rest of your existing code can remain unchanged...
export async function approveThenPayEntry(windowProvider: any) {
  if (!windowProvider) throw new Error('No wallet found');
  
  // Check if we're in MiniPay
  const isMiniPay = window.navigator.userAgent.includes('MiniPay');
  console.log("Starting payment process", isMiniPay ? "in MiniPay" : "in standard browser");
  
  try {
    await ensureCelo(windowProvider);
  } catch (e: any) {
    console.error("Network check error:", e);
    if (e?.message?.includes('Please') || e?.message?.includes('Celo')) {
      throw e;
    } else {
      throw new Error('Please ensure you are connected to the Celo network');
    }
  }

  const wallet = createWalletClient({ chain: celo, transport: custom(windowProvider) });
  const [account] = await wallet.getAddresses();
  if (!account) throw new Error('No account connected');
  
  console.log(`Using account: ${account}`);

  const c = quizContract();
  
  // Fetch contract data with error handling
  console.log("Fetching contract data (entry fee and cUSD address)...");
  let entryFee, cUSD;
  try {
    [entryFee, cUSD] = await Promise.all([c.read.entryFee(), c.read.cUSD()]);
    console.log(`Entry fee: ${entryFee}, cUSD address: ${cUSD}`);
  } catch (error) {
    console.error("Error fetching contract data:", error);
    // Use defaults if fetch fails
    entryFee = BigInt(10000);
    cUSD = "0x765DE816845861e75A25fCA122bb6898B8B1282a";
    console.log(`Using default values - Entry fee: ${entryFee}, cUSD address: ${cUSD}`);
  }
  
  // Use the explicitly defined ERC20 ABI to avoid any issues
  const erc20 = getContract({ address: cUSD as `0x${string}`, abi: erc20Abi, client: pub });

  // For MiniPay: Use an extremely large approval to avoid future issues
  // 10^6 times the entry fee should be plenty for all future transactions
  const approvalAmount = isMiniPay ? entryFee * BigInt(1000000) : entryFee;
  
  console.log(`Will approve ${approvalAmount} tokens (${isMiniPay ? "large amount for MiniPay" : "standard amount"})`);

  // SIMPLIFY FOR MINIPAY: Always approve, regardless of current allowance
  if (isMiniPay) {
    try {
      console.log("Sending approval transaction...");
      
      const hash = await wallet.writeContract({
        account,
        address: cUSD as `0x${string}`,
        abi: erc20Abi,
        functionName: 'approve',
        args: [QUIZ_ADDRESS, approvalAmount],
      });
      
      console.log(`Approval transaction sent with hash: ${hash}`);
      
      // Add a very long delay for MiniPay (10 seconds)
      console.log("Waiting 15 seconds for MiniPay approval confirmation...");
      await new Promise(resolve => setTimeout(resolve, 15000));
      
    } catch (e: any) {
      console.error('Approval error:', e);
      if (e?.message?.includes('user rejected')) {
        throw new Error('Transaction was cancelled');
      }
      throw new Error('Failed to approve tokens: ' + (e?.message || String(e)));
    }
  } else {
    // Standard browsers: Check allowance first
    let allowance;
    try {
      allowance = await erc20.read.allowance([account, QUIZ_ADDRESS]);
      console.log(`Current allowance: ${allowance}, Required: ${entryFee}`);
    } catch (error) {
      console.error("Error reading allowance:", error);
      allowance = BigInt(0);
    }
    
    if (allowance < entryFee) {
      try {
        console.log(`Approving ${entryFee} tokens...`);
        await wallet.writeContract({
          account,
          address: cUSD as `0x${string}`,
          abi: erc20Abi,
          functionName: 'approve',
          args: [QUIZ_ADDRESS, entryFee],
        });
      } catch (e: any) {
        console.error('Approval error:', e);
        if (e?.message?.includes('user rejected')) {
          throw new Error('Transaction was cancelled');
        }
        throw new Error('Failed to approve tokens: ' + (e?.message || String(e)));
      }
    } else {
      console.log("Existing allowance is sufficient, skipping approval");
    }
  }

  // Proceed with payment
  try {
    console.log("Proceeding with payment transaction...");
    
    const paymentParams = {
      account,
      address: QUIZ_ADDRESS,
      abi, // Use the safely processed ABI
      functionName: 'payEntryFee',
      args: [],
    };
    
    const hash = await wallet.writeContract(paymentParams);
    console.log(`Payment transaction hash: ${hash}`);
    
    // Add delay after payment for MiniPay
    if (isMiniPay) {
      console.log("Waiting after payment transaction...");
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
    
    return hash;
  } catch (e: any) {
    console.error('Payment error:', e);
    
    // For debugging in MiniPay
    if (isMiniPay) {
      console.log("Detailed error:", JSON.stringify(e));
    }
    
    if (e?.message?.includes('user rejected')) {
      throw new Error('Transaction was cancelled');
    } else if (e?.message?.includes('insufficient funds')) {
      throw new Error('Insufficient funds to pay entry fee');
    } else if (e?.message?.includes('insufficient allowance') || 
              (e?.message?.includes('execution reverted') && e?.message?.includes('allowance'))) {
      if (isMiniPay) {
        // Special message for MiniPay
        throw new Error('The approval transaction may take longer to confirm in MiniPay. Please try again in 15-20 seconds.');
      } else {
        throw new Error('The approval transaction has not completed yet. Please wait a moment and try again.');
      }
    } else if (e?.message?.includes('eth_estimateGas') && e?.message?.includes('allowance')) {
      throw new Error('Please wait 15-20 seconds for the approval to be confirmed, then try again.');
    } else if (e?.message?.includes('is not iterable')) {
      throw new Error('There was an issue with the contract data. Please refresh the page and try again.');
    }
    
    throw new Error('Failed to pay entry fee: ' + (e?.message || String(e)));
  }
}

async function ensureCelo(windowProvider: any) {
  // Check if we're in MiniPay
  const isMiniPay = window.navigator.userAgent.includes('MiniPay');
  
  // First check what network we're currently on
  const chainId = await windowProvider.request({ method: 'eth_chainId' });
  const correctChainId: Hex = '0xa4ec'; // 42220
  const correctChainIdDecimal = '42220';
  
  // If we're already on the Celo network, return early
  if (chainId === correctChainId || chainId === correctChainIdDecimal) {
    return;
  }
  
  // Not on Celo network
  if (isMiniPay) {
    // For MiniPay, provide clear instructions
    throw new Error('Please switch to Celo network in MiniPay: Tap the network name at the top of the app and select "Celo Mainnet"');
  }
  
  // For other wallets that support network switching
  try {
    await windowProvider.request({ 
      method: 'wallet_switchEthereumChain', 
      params: [{ chainId: correctChainId }] 
    });
  } catch (e: any) {
    // Only try to add the chain if the wallet supports it (error code 4902)
    if (e?.code === 4902) {
      try {
        await windowProvider.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: correctChainId,
            chainName: 'Celo Mainnet',
            nativeCurrency: { name: 'CELO', symbol: 'CELO', decimals: 18 },
            rpcUrls: [import.meta.env.VITE_CELO_RPC || 'https://forno.celo.org'],
            blockExplorerUrls: ['https://celoscan.io']
          }]
        });
      } catch (addError) {
        throw new Error('Please manually switch to Celo Mainnet in your wallet settings');
      }
    } else if (e?.message?.includes('does not exist')) {
      // Wallet doesn't support switching
      throw new Error('Please manually switch to Celo Mainnet in your wallet');
    } else {
      throw e;
    }
  }
}

/* Rest of your API functions remain unchanged */